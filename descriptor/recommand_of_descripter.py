# 描述符用法建议：
# 1，使用特性以保持简单：
# 　内置的property类创建的其实是覆盖型描述符，__set__ 方法和 __get__ 方法都实现了，即便不定义设值方法也是如此。
#   特性的 __set__ 方法默认抛出 AttributeError: can't set attribute，因此创建只读属性最简单的方式是使用特性，这能避免下一条所述的问题。

# 2，只读描述符必须有 __set__ 方法
#   如果使用描述符类实现只读属性，要记住，__get__ 和 __set__ 两个方法必须都定义，否则，实例的同名属性会遮盖描述符。
#   只读属性的 __set__ 方法只需抛出 AttributeError 异常，并提供合适的错误消息。


# 3，用于验证的描述符可以只有 __set__ 方法
#   对仅用于验证的描述符来说，__set__ 方法应该检查 value 参数获得的值，
#   如果有效，使用描述符实例的名称为键，直接在实例的 __dict__ 属性中设置。
#   这样，从实例中读取同名属性的速度很快，因为不用经过 __get__ 方法处理。


# 4，仅有 __get__ 方法的描述符可以实现高效缓存
#   如果只编写了 __get__ 方法，那么创建的是非覆盖型描述符。
#   这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。
#   同名实例属性会遮盖描述符，因此后续访问会直接从实例的 __dict__ 属性中获取值，而不会再触发描述符的 __get__ 方法。


# 5，非特殊的方法可以被实例属性遮盖
#   由于函数和方法只实现了 __get__ 方法，它们不会处理同名实例属性的赋值操作。
#   因此，像 my_obj.the_method = 7 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7——但是不影响类或其他实例。
#   然而，特殊方法不受这个问题的影响。
#   解释器只会在类中寻找特殊的方法，也就是说，repr(x)执行的其实是 x.__class__.__repr__(x)，因此 x 的 __repr__ 属性对 repr(x) 方法调用没有影响。
#   出于同样的原因，实例的 __getattr__ 属性不会破坏常规的属性访问规则。
